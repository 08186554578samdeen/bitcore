#!/usr/bin/env node

'use strict';

const program = require('commander');
const { Wallet } = require('../ts_build/src/wallet');
const promptly = require('promptly');
const { Web3 } = require('crypto-wallet-core');

program
  .version(require('../package.json').version)
  .description('Bump the fee of a transaction. If it\'s a UTXO chain, it will deduct from the change output.')
  .requiredOption('--name <name>', 'REQUIRED - Wallet Name')
  .option('-t, --txid <txid>', 'Transaction id (either this or --raw are required)')
  .option('-r, --raw <hex>', 'Raw transaction (either this or --txid are required)')
  .option('-c, --change <index>', 'Specify the change output index to deduct the new fee from (REQUIRED for UTXO chains)')
  .option('-f, --feeRate <rate>', 'optional - Rate in sats/byte or Gwei')
  .option('-T, --feeTarget <nBlocks>', 'optional - Number of blocks to confirm in (defaults to 2)')
  .option('-P, --feePriority <rate>', 'optional - Priority fee for EVM type 2 txs in Gwei')
  .option('-q, --quiet', 'optional - Do not prompt for confirmation or show raw tx data')
  .option('--noRbf', 'optional - Disable replace-by-fee')
  .option('--isSweep', 'optional - Force treat the transaction as a sweep. Useful for when the --change is not an address controlled by the wallet')
  .option('--storageType <storageType>', 'optional - Name of the database to use (default Level)')
  .option('--path <path>', 'optional - Custom wallet storage path')
  .parse(process.argv);

const main = async () => {
  const { name, path, storageType = 'Level', raw: rawTx, change, feeRate, feeTarget = 2, feePriority, quiet, noRbf, isSweep } = program.opts();
  let { txid } = program.opts();
  let wallet;
  
  try {
    wallet = await Wallet.loadWallet({ name, path, storageType });

    if (change == null && wallet.isUtxoChain()) {
      throw new Error('Must provide --change for UTXO chains');
    }

    const lib = wallet.getLib();
    let existingTx;
    if (rawTx) {
      if (lib.ethers) {
        existingTx = lib.ethers.utils.parseTransaction(rawTx);
      } else {
        const tx = new lib.Transaction(rawTx);
        txid = tx.id;
      }
    }
    if (txid) {
      existingTx = await wallet.getTransactionByTxid({ txid, populated: wallet.isUtxoChain() });
    } else if (!existingTx) {
      throw new Error('Must provide either --raw or --txid.');
    }

    const params = {};

    if (wallet.isUtxoChain()) {
      const { coins: { inputs, outputs }, locktime } = existingTx;

      params.utxos = inputs;
      params.change = outputs.find(o => o.mintIndex == change).address;
      params.recipients = outputs.filter(o => o.mintIndex != change).map(o => ({ address: o.address, amount: o.value }));
      params.lockUntilBlock = locktime > 0 ? locktime : undefined;
      params.replaceByFee = !noRbf;
      params.isSweep = isSweep ?? outputs.length === 1;
      if (feeRate) {
        params.feeRate = feeRate;
      } else {
        params.feeRate = (await wallet.getNetworkFee({ target: feeTarget })).feerate;
        console.log(`Bumping fee rate to ${params.feeRate} sats/byte`);
      }

    // EVM chains
    } else {
      const { nonce, gasLimit, gasPrice, to, data, value, chainId, type } = existingTx;
      // converting gasLimit and value with toString avoids a bigNumber warning
      params.nonce = nonce
      params.gasLimit = gasLimit?.toString();
      params.gasPrice = gasPrice;
      params.data = data;
      params.chainId = chainId;
      params.type = type;
      params.recipients = [{ address: to, amount: value.toString() }];
      
      // TODO fix type2 support
      if (false && existingTx.type === 2) {
        if (feeRate) {
          params.maxGasFee = Web3.utils.toWei(feeRate.toString(), 'gwei');
        } else {
          // TODO placeholder until for type2 support is merged in another PR
          // params.maxGasFee = (await wallet.getNetworkFee({ target: feeTarget })).feerate;
          // console.log(`Bumping max gas price to ${Web3.utils.fromWei(params.maxGasFee.toString(), 'gwei')} gwei`);
        }
        if (feePriority) {    
          params.maxPriorityFee = Web3.utils.toWei(feePriority.toString(), 'gwei');
        } else {
          // TODO placeholder until for type2 support is merged in another PR
          // params.maxPriorityFee = existingTx.maxPriorityFeePerGas;
          // console.log(`Bumping max priority fee to ${Web3.utils.fromWei(params.maxPriorityFee.toString(), 'gwei')} gwei`);
        }

      // type 0
      } else {
        if (feeRate) {
          params.gasPrice = Web3.utils.toWei(feeRate.toString(), 'gwei');
        } else {
          params.gasPrice = (await wallet.getNetworkFee({ target: feeTarget })).feerate;
          console.log(`Bumping gas price to ${Web3.utils.fromWei(params.gasPrice.toString(), 'gwei')} gwei`);
        }
      }
      
    }

    const tx = await wallet.newTx(params);
    !quiet && console.log('UnsignedRawTx: ', tx);
    const passphrase = await promptly.password('Wallet Password:');
    wallet = await wallet.unlock(passphrase);
    const signedTx = await wallet.signTx({ tx, passphrase, utxos: params.utxos });
    if (!quiet) {
      console.log('SignedRawTx: ', signedTx);
      const confirmed = await promptly.confirm('Broadcast? (y/n)');
      if (!confirmed) {
        return;
      }
    }
    const transaction = await wallet.broadcast({ tx: signedTx });
    console.log('Txid: ', transaction.txid);
    console.log('Transaction broadcasted');
  } catch (e) {
    console.error(e);
  }
};

main();
